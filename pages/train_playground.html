<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Training Playground</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #333;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
        }

        .controls {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: inline-block;
            width: 150px;
            font-weight: bold;
        }

        .control-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .target-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .target-btn {
            padding: 10px 20px;
            border: 2px solid #ddd;
            background-color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .target-btn:hover {
            background-color: #f0f0f0;
        }

        .target-btn.selected {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        input[type="range"] {
            width: 200px;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-primary {
            background-color: #2196F3;
            color: white;
        }

        .btn-primary:hover {
            background-color: #1976D2;
        }

        .btn-success {
            background-color: #4CAF50;
            color: white;
        }

        .btn-success:hover {
            background-color: #45a049;
        }

        .btn-warning {
            background-color: #ff9800;
            color: white;
        }

        .btn-warning:hover {
            background-color: #e68900;
        }

        .btn-danger {
            background-color: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background-color: #da190b;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .network-section {
            grid-column: 1 / -1;
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .network-section h3 {
            margin-top: 0;
            color: #333;
        }

        #network-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
            min-height: 300px;
            position: relative;
        }

        .layer {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            z-index: 10;
        }

        .layer-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #666;
            font-size: 12px;
        }

        .neuron {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px solid #999;
            position: relative;
            cursor: default;
        }

        .neuron-label {
            font-size: 9px;
            font-weight: bold;
            text-align: center;
        }

        .neuron-value {
            font-size: 9px;
            color: #666;
            font-family: monospace;
        }

        .neuron-probability {
            position: absolute;
            right: -55px;
            font-size: 10px;
            font-family: monospace;
            background-color: #e8f5e9;
            padding: 2px 5px;
            border-radius: 3px;
            border: 1px solid #4CAF50;
        }

        #connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .chart-container {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
        }

        .chart-container h3 {
            margin-top: 0;
            color: #333;
        }

        #lossChart, #probChart {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            background-color: white;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            font-family: monospace;
        }

        .probability-bars {
            margin-top: 10px;
        }

        .prob-bar-container {
            margin-bottom: 10px;
        }

        .prob-bar-label {
            font-size: 12px;
            margin-bottom: 3px;
            font-weight: bold;
        }

        .prob-bar-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .prob-bar {
            flex: 1;
            height: 25px;
            background-color: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .prob-bar-fill {
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }

        .prob-bar-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }

        .prob-value {
            font-family: monospace;
            font-size: 12px;
            min-width: 60px;
        }

        #networkViz {
            grid-column: 1 / -1;
            min-height: 400px;
        }

        .value-display {
            display: inline-block;
            min-width: 60px;
            font-family: monospace;
            font-size: 14px;
        }

        .training-indicator {
            display: inline-block;
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border-radius: 3px;
            font-size: 12px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Neural Network Training Playground</h1>
        <p class="subtitle">Train the network to maximize any output logit and observe the loss curve in real-time</p>

        <div class="controls">
            <div class="control-group">
                <label>Training Target:</label>
                <div class="target-buttons">
                    <button class="target-btn" data-target="0">hello</button>
                    <button class="target-btn" data-target="1">hola</button>
                    <button class="target-btn" data-target="2">HELLO</button>
                    <button class="target-btn" data-target="3">HOLA</button>
                </div>
            </div>

            <div class="control-row">
                <div class="control-group">
                    <label>Learning Rate:</label>
                    <input type="range" id="learningRate" min="0.001" max="1" step="0.001" value="0.1">
                    <span class="value-display" id="learningRateValue">0.100</span>
                </div>

                <div class="control-group">
                    <label>Steps per Click:</label>
                    <input type="number" id="stepsPerClick" min="1" max="100" value="1">
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn-primary" id="stepBtn">Single Step</button>
                <button class="btn-success" id="train10Btn">Train 10 Steps</button>
                <button class="btn-success" id="train100Btn">Train 100 Steps</button>
                <button class="btn-warning" id="autoTrainBtn">Auto Train</button>
                <button class="btn-danger" id="resetBtn">Reset Network</button>
            </div>

            <div class="training-indicator hidden" id="trainingIndicator">Training...</div>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Training Steps</div>
                <div class="stat-value" id="stepCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Current Loss</div>
                <div class="stat-value" id="currentLoss">-</div>
            </div>
        </div>

        <div class="network-section">
            <h3>Network State (Live)</h3>
            <div id="network-container"></div>
        </div>

        <div class="main-content">
            <div class="chart-container">
                <h3>Loss Curve</h3>
                <canvas id="lossChart"></canvas>
            </div>

            <div class="chart-container">
                <h3>Output Probabilities</h3>
                <div class="probability-bars">
                    <div class="prob-bar-container">
                        <div class="prob-bar-label">hello</div>
                        <div class="prob-bar-wrapper">
                            <div class="prob-bar">
                                <div class="prob-bar-fill" id="prob0"></div>
                                <div class="prob-bar-text" id="probText0">0%</div>
                            </div>
                            <div class="prob-value" id="probVal0">0.0000</div>
                        </div>
                    </div>
                    <div class="prob-bar-container">
                        <div class="prob-bar-label">hola</div>
                        <div class="prob-bar-wrapper">
                            <div class="prob-bar">
                                <div class="prob-bar-fill" id="prob1"></div>
                                <div class="prob-bar-text" id="probText1">0%</div>
                            </div>
                            <div class="prob-value" id="probVal1">0.0000</div>
                        </div>
                    </div>
                    <div class="prob-bar-container">
                        <div class="prob-bar-label">HELLO</div>
                        <div class="prob-bar-wrapper">
                            <div class="prob-bar">
                                <div class="prob-bar-fill" id="prob2"></div>
                                <div class="prob-bar-text" id="probText2">0%</div>
                            </div>
                            <div class="prob-value" id="probVal2">0.0000</div>
                        </div>
                    </div>
                    <div class="prob-bar-container">
                        <div class="prob-bar-label">HOLA</div>
                        <div class="prob-bar-wrapper">
                            <div class="prob-bar">
                                <div class="prob-bar-fill" id="prob3"></div>
                                <div class="prob-bar-text" id="probText3">0%</div>
                            </div>
                            <div class="prob-value" id="probVal3">0.0000</div>
                        </div>
                    </div>
                </div>
                <canvas id="probChart"></canvas>
            </div>

            <div class="chart-container" style="grid-column: 1 / -1;">
                <h3>Weight & Bias Evolution</h3>
                <div style="margin-bottom: 15px;">
                    <label style="margin-right: 10px;">Show:</label>
                    <select id="paramSelect" style="padding: 5px; border-radius: 3px; border: 1px solid #ddd;">
                        <option value="hiddenBias">Hidden Biases (4)</option>
                        <option value="outputBias">Output Biases (4)</option>
                        <option value="weights1">Input→Hidden Weights (4)</option>
                        <option value="weights2_0">Hidden→hello Weights (4)</option>
                        <option value="weights2_1">Hidden→hola Weights (4)</option>
                        <option value="weights2_2">Hidden→HELLO Weights (4)</option>
                        <option value="weights2_3">Hidden→HOLA Weights (4)</option>
                    </select>
                </div>
                <canvas id="paramChart"></canvas>
            </div>
        </div>
    </div>

    <script src="../src/network.js"></script>
    <script src="../src/train.js"></script>
    <script>
        // Initialize network and trainer
        const network = new NeuralNetwork();
        const trainer = new Trainer(network);

        // State
        let selectedTarget = null;
        let isAutoTraining = false;
        let autoTrainInterval = null;

        // Chart contexts
        const lossCtx = document.getElementById('lossChart').getContext('2d');
        const probCtx = document.getElementById('probChart').getContext('2d');
        const paramCtx = document.getElementById('paramChart').getContext('2d');

        // Initialize network visualization
        setupNetworkVisualization();

        // Initialize
        network.forward();
        updateUI();

        // Parameter selection handler
        document.getElementById('paramSelect').addEventListener('change', function() {
            const history = trainer.getHistory();
            drawParameterChart(history);
        });

        // Target selection
        document.querySelectorAll('.target-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.target-btn').forEach(b => b.classList.remove('selected'));
                this.classList.add('selected');
                selectedTarget = parseInt(this.dataset.target);
            });
        });

        // Learning rate slider
        document.getElementById('learningRate').addEventListener('input', function() {
            document.getElementById('learningRateValue').textContent = parseFloat(this.value).toFixed(3);
        });

        // Single step button
        document.getElementById('stepBtn').addEventListener('click', function() {
            if (selectedTarget === null) {
                alert('Please select a training target first');
                return;
            }
            const lr = parseFloat(document.getElementById('learningRate').value);
            trainer.trainStep(selectedTarget, lr);
            updateUI();
        });

        // Train 10 steps button
        document.getElementById('train10Btn').addEventListener('click', function() {
            if (selectedTarget === null) {
                alert('Please select a training target first');
                return;
            }
            const lr = parseFloat(document.getElementById('learningRate').value);
            trainMultipleSteps(10, lr);
        });

        // Train 100 steps button
        document.getElementById('train100Btn').addEventListener('click', function() {
            if (selectedTarget === null) {
                alert('Please select a training target first');
                return;
            }
            const lr = parseFloat(document.getElementById('learningRate').value);
            trainMultipleSteps(100, lr);
        });

        // Auto train button
        document.getElementById('autoTrainBtn').addEventListener('click', function() {
            if (selectedTarget === null) {
                alert('Please select a training target first');
                return;
            }

            if (isAutoTraining) {
                stopAutoTrain();
            } else {
                startAutoTrain();
            }
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', function() {
            if (isAutoTraining) {
                stopAutoTrain();
            }
            trainer.reset();
            network.forward();
            selectedTarget = null;
            document.querySelectorAll('.target-btn').forEach(b => b.classList.remove('selected'));
            updateUI();
        });

        // Network Visualization Setup
        function setupNetworkVisualization() {
            const container = document.getElementById('network-container');

            // Create SVG for connections
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.id = 'connections-svg';
            container.appendChild(svg);

            // Create layers
            const inputLayer = createLayer('Input', network.inputNames, 'input');
            const hiddenLayer = createLayer('Hidden', network.hiddenNames, 'hidden');
            const outputLayer = createLayer('Output', network.outputNames, 'output');

            container.appendChild(inputLayer);
            container.appendChild(hiddenLayer);
            container.appendChild(outputLayer);
        }

        function createLayer(title, labels, layerType) {
            const layer = document.createElement('div');
            layer.className = 'layer';

            const titleDiv = document.createElement('div');
            titleDiv.className = 'layer-title';
            titleDiv.textContent = title;
            layer.appendChild(titleDiv);

            labels.forEach((label, i) => {
                const neuron = document.createElement('div');
                neuron.className = 'neuron';
                neuron.id = `neuron-${layerType}-${i}`;

                const labelDiv = document.createElement('div');
                labelDiv.className = 'neuron-label';
                labelDiv.textContent = label;
                neuron.appendChild(labelDiv);

                const valueDiv = document.createElement('div');
                valueDiv.className = 'neuron-value';
                valueDiv.id = `value-${layerType}-${i}`;
                neuron.appendChild(valueDiv);

                if (layerType === 'output') {
                    const probDiv = document.createElement('div');
                    probDiv.className = 'neuron-probability';
                    probDiv.id = `prob-network-${i}`;
                    neuron.appendChild(probDiv);
                }

                layer.appendChild(neuron);
            });

            return layer;
        }

        function updateNetworkVisualization() {
            // Update input values
            document.getElementById('value-input-0').textContent = network.inputWithBias[0].toFixed(2);

            // Update hidden values
            for (let i = 0; i < network.hiddenSize; i++) {
                document.getElementById(`value-hidden-${i}`).textContent =
                    network.hiddenWithBias[i].toFixed(2);

                // Color by activation level
                const activation = network.hiddenWithBias[i];
                const neuron = document.getElementById(`neuron-hidden-${i}`);
                const intensity = Math.min(255, Math.max(0, Math.floor(activation * 100)));
                neuron.style.backgroundColor = `rgb(${255 - intensity}, ${255 - intensity/2}, ${255 - intensity})`;
            }

            // Update output values
            for (let i = 0; i < network.outputSize; i++) {
                document.getElementById(`value-output-${i}`).textContent =
                    network.outputPreActivation[i].toFixed(2);
                document.getElementById(`prob-network-${i}`).textContent =
                    (network.outputActivation[i] * 100).toFixed(1) + '%';

                // Color by probability
                const prob = network.outputActivation[i];
                const neuron = document.getElementById(`neuron-output-${i}`);
                const intensity = Math.floor(prob * 200);
                neuron.style.backgroundColor = `rgb(${200 - intensity}, ${255 - intensity/2}, ${200 - intensity})`;
            }

            // Draw connections
            drawConnections();
        }

        function drawConnections() {
            const svg = document.getElementById('connections-svg');
            svg.innerHTML = '';

            const container = document.getElementById('network-container');
            const rect = container.getBoundingClientRect();

            // Helper to get neuron center
            function getNeuronCenter(layerType, index) {
                const neuron = document.getElementById(`neuron-${layerType}-${index}`);
                const neuronRect = neuron.getBoundingClientRect();
                return {
                    x: neuronRect.left + neuronRect.width / 2 - rect.left,
                    y: neuronRect.top + neuronRect.height / 2 - rect.top
                };
            }

            // Draw weights1 connections (input -> hidden)
            for (let i = 0; i < network.inputSize; i++) {
                for (let h = 0; h < network.hiddenSize; h++) {
                    const from = getNeuronCenter('input', i);
                    const to = getNeuronCenter('hidden', h);
                    const weight = network.weights1[i][h];
                    drawConnection(svg, from, to, weight);
                }
            }

            // Draw weights2 connections (hidden -> output)
            for (let h = 0; h < network.hiddenSize; h++) {
                for (let o = 0; o < network.outputSize; o++) {
                    const from = getNeuronCenter('hidden', h);
                    const to = getNeuronCenter('output', o);
                    const weight = network.weights2[h][o];
                    drawConnection(svg, from, to, weight);
                }
            }
        }

        function drawConnection(svg, from, to, weight) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', from.x);
            line.setAttribute('y1', from.y);
            line.setAttribute('x2', to.x);
            line.setAttribute('y2', to.y);

            // Color based on weight
            const color = weight > 0 ? 'green' : 'red';
            const opacity = Math.min(1, Math.abs(weight) / 2);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-opacity', opacity);
            line.setAttribute('stroke-width', Math.max(0.5, Math.abs(weight) * 1.5));

            svg.appendChild(line);
        }

        function trainMultipleSteps(numSteps, learningRate) {
            for (let i = 0; i < numSteps; i++) {
                trainer.trainStep(selectedTarget, learningRate);
            }
            updateUI();
        }

        function startAutoTrain() {
            isAutoTraining = true;
            document.getElementById('autoTrainBtn').textContent = 'Stop Training';
            document.getElementById('autoTrainBtn').classList.remove('btn-warning');
            document.getElementById('autoTrainBtn').classList.add('btn-danger');
            document.getElementById('trainingIndicator').classList.remove('hidden');

            const lr = parseFloat(document.getElementById('learningRate').value);
            autoTrainInterval = setInterval(() => {
                trainer.trainStep(selectedTarget, lr);
                updateUI();
            }, 50); // Train every 50ms
        }

        function stopAutoTrain() {
            isAutoTraining = false;
            clearInterval(autoTrainInterval);
            document.getElementById('autoTrainBtn').textContent = 'Auto Train';
            document.getElementById('autoTrainBtn').classList.remove('btn-danger');
            document.getElementById('autoTrainBtn').classList.add('btn-warning');
            document.getElementById('trainingIndicator').classList.add('hidden');
        }

        function updateUI() {
            const history = trainer.getHistory();
            const state = trainer.getCurrentState();

            // Update stats
            document.getElementById('stepCount').textContent = history.steps.length;
            document.getElementById('currentLoss').textContent =
                state.loss !== null ? state.loss.toFixed(4) : '-';

            // Update probability bars
            for (let i = 0; i < 4; i++) {
                const prob = state.probabilities[i];
                const percentage = (prob * 100).toFixed(1);
                document.getElementById(`prob${i}`).style.width = percentage + '%';
                document.getElementById(`probText${i}`).textContent = percentage + '%';
                document.getElementById(`probVal${i}`).textContent = prob.toFixed(4);
            }

            // Update network visualization
            updateNetworkVisualization();

            // Update charts
            drawLossChart(history);
            drawProbabilityChart(history);
            drawParameterChart(history);
        }

        function drawLossChart(history) {
            const canvas = document.getElementById('lossChart');
            const ctx = lossCtx;
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, width, height);

            if (history.losses.length === 0) {
                ctx.fillStyle = '#999';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No training data yet', width / 2, height / 2);
                return;
            }

            // Find min/max for scaling
            const maxLoss = Math.max(...history.losses);
            const minLoss = Math.min(...history.losses);
            const lossRange = maxLoss - minLoss || 1;

            // Padding
            const padding = 40;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Draw loss curve
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 2;
            ctx.beginPath();

            history.losses.forEach((loss, i) => {
                const x = padding + (i / Math.max(history.losses.length - 1, 1)) * chartWidth;
                const y = height - padding - ((loss - minLoss) / lossRange) * chartHeight;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();

            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Steps', width / 2, height - 5);

            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Loss', 0, 0);
            ctx.restore();

            // Draw min/max values
            ctx.textAlign = 'right';
            ctx.fillText(maxLoss.toFixed(3), padding - 5, padding + 5);
            ctx.fillText(minLoss.toFixed(3), padding - 5, height - padding + 5);
        }

        function drawProbabilityChart(history) {
            const canvas = document.getElementById('probChart');
            const ctx = probCtx;
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = 250;
            canvas.height = height;

            ctx.clearRect(0, 0, width, height);

            if (history.probabilities.length === 0) {
                return;
            }

            const padding = 40;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Draw probability curves
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A'];
            const labels = ['hello', 'hola', 'HELLO', 'HOLA'];

            for (let outputIdx = 0; outputIdx < 4; outputIdx++) {
                ctx.strokeStyle = colors[outputIdx];
                ctx.lineWidth = 2;
                ctx.beginPath();

                history.probabilities.forEach((probs, i) => {
                    const x = padding + (i / Math.max(history.probabilities.length - 1, 1)) * chartWidth;
                    const y = height - padding - probs[outputIdx] * chartHeight;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();

                // Draw legend
                const legendX = width - padding - 80;
                const legendY = padding + outputIdx * 20;
                ctx.fillStyle = colors[outputIdx];
                ctx.fillRect(legendX, legendY, 15, 10);
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(labels[outputIdx], legendX + 20, legendY + 9);
            }

            // Draw y-axis labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('1.0', padding - 5, padding + 5);
            ctx.fillText('0.5', padding - 5, height - padding - chartHeight / 2 + 5);
            ctx.fillText('0.0', padding - 5, height - padding + 5);
        }
        function drawParameterChart(history) {
            const canvas = document.getElementById('paramChart');
            const ctx = paramCtx;
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = 250;
            canvas.height = height;

            ctx.clearRect(0, 0, width, height);

            if (history.steps.length === 0) {
                ctx.fillStyle = '#999';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No training data yet', width / 2, height / 2);
                return;
            }

            const selectedParam = document.getElementById('paramSelect').value;
            const padding = 40;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;

            // Extract parameter data
            let paramData = [];
            let labels = [];

            if (selectedParam === 'hiddenBias') {
                labels = network.hiddenNames;
                for (let i = 0; i < 4; i++) {
                    paramData.push(history.hiddenBias.map(b => b[i]));
                }
            } else if (selectedParam === 'outputBias') {
                labels = network.outputNames;
                for (let i = 0; i < 4; i++) {
                    paramData.push(history.outputBias.map(b => b[i]));
                }
            } else if (selectedParam === 'weights1') {
                labels = network.hiddenNames;
                for (let h = 0; h < 4; h++) {
                    paramData.push(history.weights1.map(w => w[0][h]));
                }
            } else if (selectedParam.startsWith('weights2_')) {
                const outputIdx = parseInt(selectedParam.split('_')[1]);
                labels = network.hiddenNames;
                for (let h = 0; h < 4; h++) {
                    paramData.push(history.weights2.map(w => w[h][outputIdx]));
                }
            }

            // Find min/max for scaling
            const allValues = paramData.flat();
            const maxVal = Math.max(...allValues);
            const minVal = Math.min(...allValues);
            const valRange = maxVal - minVal || 1;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Draw parameter curves
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A'];

            paramData.forEach((data, idx) => {
                ctx.strokeStyle = colors[idx];
                ctx.lineWidth = 2;
                ctx.beginPath();

                data.forEach((val, i) => {
                    const x = padding + (i / Math.max(data.length - 1, 1)) * chartWidth;
                    const y = height - padding - ((val - minVal) / valRange) * chartHeight;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();

                // Draw legend
                const legendX = width - padding - 100;
                const legendY = padding + idx * 20;
                ctx.fillStyle = colors[idx];
                ctx.fillRect(legendX, legendY, 15, 10);
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(labels[idx], legendX + 20, legendY + 9);
            });

            // Draw y-axis labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(maxVal.toFixed(2), padding - 5, padding + 5);
            ctx.fillText(((maxVal + minVal) / 2).toFixed(2), padding - 5, height - padding - chartHeight / 2 + 5);
            ctx.fillText(minVal.toFixed(2), padding - 5, height - padding + 5);

            // Draw x-axis label
            ctx.textAlign = 'center';
            ctx.fillText('Training Steps', width / 2, height - 5);

            // Draw y-axis label
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Parameter Value', 0, 0);
            ctx.restore();
        }
    </script>
</body>
</html>
